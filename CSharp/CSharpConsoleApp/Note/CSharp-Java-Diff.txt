Java和C#代码替换常见误区

1.  字符串

	字符串截取
	string.subString(i, j)		//Java   startIndex, endIndex,  第二个参数为结束索引号j
	string.SubString(i, j-i);	//C#     startIndex, length     第二个参数为截取长度，也就是 j-i;

2. Array
	
	Arrays  //Java
	Array   //C#

	Arrays.binarySearch(object[ ], object key);     //Java写法
	Array.binarySearch(object[ ], object key);      //C#写法

	/*********** Arrays.binarySearch 测试代码 ************/
	public static void main (String []args)
    {
        int a[] = new int[] {1, 3, 4, 6, 8, 9};
        int x1 = Arrays.binarySearch(a, 5);
        int x2 = Arrays.binarySearch(a, 4);
        int x3 = Arrays.binarySearch(a, 0);
        int x4 = Arrays.binarySearch(a, 10);
        System.out.println("x1:" + x1 + ", x2:" + x2);
        System.out.println("x3:" + x3 + ", x4:" + x4);
    }
	/*********** 输出结果：***********/
	x1:-4, x2:2
	x3:-1, x4:-7
	/// 如果key在数组中，则返回搜索值的索引；否则返回-1或者”-“(插入点)。
	/// 关键: 插入点索引从1开始。
	/// 所以搜索5的时候，前面是4，对应索引2，本应返回-3，
	/// 但是索引从1开始，返回-4.
	/*********** 输出结果：***********/

3. List

	List和LinkedList
	List<String> list = new LinkedList<String>();   //Java写法
	LinkedList<String> listOrg = new LinkedList<String>();	//C#写法, C#中 LinkedList不是List的子类。
	List<String> list = listOrg.ToList<string>();           //C#写法, LinkedList可以通过 ToList<T>方法转换为List;

	int id = LinkedList.remove ：//Java写法 获取并移除此列表的头(第一个元素)。
	int id = LinkedLis.First();  //C#写法   获取列表的头(第一个元素)。
    LinkedLis.RemoveFirst();     //C#写法   移除此列表的头(第一个元素)。

	------------------------------------------------------------------
	Queue<int> queue = new LinkedList<>();         //Java写法
	queue.offer(10);                               //Java写
	
	LinkedList<int> queue = new LinkedList<int>(); //C#写法
	queue.AddLast(10);                             //C#写法
	------------------------------------------------------------------
	T t = queue.poll();                            //Java写 取值并删除 （对应C#两行）

	T t = queue.Last();                            //C#写法 先取值
    queue.RemoveLast();                            //C#写法 再删除
	------------------------------------------------------------------

3.  数据结构对照
	
	3.1 栈
		Deque<Integer> xStack;	//Java Deque 实现了 ArrayDeque
		Stack<int> xStack;      //C#
		stack<int> xStack;      //C++
 
        xStack.addLast(0);            //Java
        xStack.Push(0);               //C#

        xStack.removeLast();          //Java
        xStack.Pop();                 //C#


        xStack.peekLast();            //Java  取得栈顶
		xStack.peek();                //Java  取得栈顶
        xStack.Peek();                //C#    取得栈顶  或xStack.First<int>(); 需要 using System.Linq;
		xStack.FirstOrDefault<int>(); //C#    取得栈顶  或xStack.First<int>(); 需要 using System.Linq;
		xStack.top();                 //C++   取得栈顶

	
	3.2 堆
		priority_queue<pair<int, int>> q;                                           //C++
		PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>(); //Java

			poll 方法每次从 PriorityQueue 的头部删除一个节点，也就是从小顶堆的堆顶删除一个节点
			remove 方法不仅可以删除头节点
				而且还可以用 remove(Object o) 来删除堆中的与给定对象相同的最先出现的对象

		PriorityQueue.offer 相当于 Queue.Push();
		PriorityQueue.poll  相当于 Queue.Pop();

   3.3 TreeSet
        Java TreeSet简介
        TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet<E>, Cloneable, java.io.Serializable接口。
        TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。支持add、remove、get等方法。
        TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。
        TreeSet 实现了Cloneable接口，意味着它能被克隆。
        TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。
        TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。
        TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。
        另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。
        ————————————————
        版权声明：本文为CSDN博主「南     墙」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
        原文链接：https://blog.csdn.net/a1439775520/article/details/95373610

        c# //这将是System.Collections.Generic.SortedSet<T>。

   3.4 哈希表
       C++  : Set、multiset都是集合类，差别在与set中不允许有重复元素，
              multiset中允许有重复元素。multiset不是堆，是平衡树。堆在删除时候是很慢的。
              对muliset遍历时，首先会取出横坐标小的点。如果2个点横坐标相等，会先取出 second 小的点，
              参考： https://www.cnblogs.com/shmilxu/p/4834610.html
       Java : HashMap, HashTable
       C#   : Dictionary, HashSet,

它确实具有人们期望从平衡的树支持数据结构中获得的方法和复杂性保证。您可以按顺序找到所有元素的最大值，最小值，迭代次数。

