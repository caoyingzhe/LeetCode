≠
∈ 属于，∈是指元素与集合的关系
⊆ 属于，是指集合与集合的关系
⊊ 不属于

清华大学邓俊辉老师的MOOC不香吗
	清华大学邓俊辉老师的MOOC
	https://dsa.cs.tsinghua.edu.cn/~deng/ds/mooc/

第三部分 数据结构  P129 ~ P141

第10章   基本数据结构
	10.1 栈和队列   时间复杂度为 O(1).
		
	栈
		后进先出 （Push / Pop)

		栈下溢（underflow) 对空栈进行Pop操作。
		栈下溢（overflow)  对满栈进行Push操作。

		栈头: S.top 对应数组中最后一个值的索引

	队列
		先进先出 (Enqueue / Dequeue)
		插入和删除操作分别在两端进行。

		队列头: S.head 对应数组中初始值的索引，不一定是0。
		队列尾: S.tail 对应数组中最后值的索引，不一定是数组的最大索引。

		入队时：队列头不变，队尾发生右移。超出最大索引时，放置到左侧。
		出队时：队列头向右移动，队尾不变。超出最大索引时，放置到左侧。

	双队列
		插入和删除操作均可在两端进行的队列。

	10.2 链表   时间复杂度为 O(1).

		优化：
			对于数据很长的链表，推荐使用哨兵NIL，链接头和尾，Next指向头，Pre指向尾，使链表成为循环链表。
			这样做，对于删除操作是能够降低判断时间，代码跟紧凑。

			对于短链表不推荐这么做，会占用额外内存。
		－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
		10.2-8题解：
			利用异或运算的自反性。
			设x.prev的地址为a，x.next的地址为b，r=a XOR b，
			则有
				使用一个指针x.np = r, r=a XOR b，
				a XOR r = | a XOR a XOR b | = | ba XOR r | = | a XOR a XOR b | =b，
				b XOR r = | b XOR a XOR b | = | ab XOR r | = | b XOR a XOR b | =a。

			参考文章
				https://blog.csdn.net/sinat_16709955/article/details/77611955?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=1328769.190.16172709055079665&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control
		－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

	10.3 指针和对象的实现
			
			对于不支持指针的语言实现方法：
				使用L更新链表的头
				使用三个数组，分别对应 next指针，key值，prev指针，

		－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
		10.3-3题解：
			ALLO时，产生的新节点没有prev节点，是通过L来找到的，所以不需要。
			FREE时，节点free后，prev没有意义了，因为是通过L找到新的头节点，只要更新相应L就可以了。

		10.3-4题解：
		｜数组的位置0（栈顶）
		每次添加新元素时把数组当作栈，往头部顺序添加，同时相应更新指示栈顶的位置的变量

		10.3-5题解：
			调整双链表使之紧凑 https://blog.csdn.net/zhanglei8893/article/details/6317283
			 我们可以采用交换的手法，将L中的第1个元素和数组第1个位置的元素进行交换，依次类推，
			 L中的第m个位置的元素和数组的第m个元素进行交换，每次交换仅需要常量的额外空间。
			
			COMPACTIFY-LIST(L, F) 
			{
				x ← head[L]
				num ← 0
				while x ≠ NIL
				  do num ← num+1
					 if x ≠ num
					   then SWAP-OBJECT(x, num)
					 x ← next[x]
				SWAP-OBJECT(i, j)
				exchange A[i] ↔ A[j]
				if prev[i] ≠ NIL
				  then next[prev[i]] ← j
				if next[i] ≠ NIL
				  then prev[next[i]] ← j
				if prev[j] ≠ NIL
				  then next[prev[j]] ← i
				if next[j] ≠ NIL
				  then prev[next[j]] ← i
			}
		－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

	10.4 有根树的表示
		
		左孩子右兄弟表示法（left-child, right-sibling representation)
			对于任意n个节点的有根树，只需要O(n)的存储空间。
	
	10.4-5题解：？？
	10.4-6题解：？？

	10-1题解：？？
	10-2题解：？？
	10-3题解：？？

Pg142～Pg160　(2021-0402)
第11章   散列表（哈希表）
	11.1  直接寻址表（direct-address table)

		术语
			全域U
			关键字集合K
			
		关键技术
			分析散列技术，及其变形。
			开放寻址法（open addressing)
			使用静态存储关键字集合，实现完全散列（perfect hashing)能在O(1)时间内完成关键字查询；

		11.1-2题解：？？
		11.1-3题解：？？
			卫星数据 ？？
		11.1-4
			利用附加数组(栈)，大小等于实际存储在字典中关键字数目，帮助确定大数组中的某个给定项目是否有效。

	11.2 散列表
		
		直接寻址表缺点：
			全域U很大，存储一张大小为|U|的表T需要很大的内存容量。实际不是用的大部分空间浪费严重。

		散列表
			支持Insert，Search，Delete字典操作
			最坏的情况，查询时间同链表中查询时间相同，达到近似O(n)
			合理情况下，查询元素的平均时间是O(1)
			关键字不是数组的下标，而是根据关键字计算出下标（使用散列函数 hash function,简称h(k))
			重点思想是链接（chaining）和冲突（collision)
				冲突：多个关键字映射到同一下标	
		
		术语
			全域U
			关键字集合K
			散列表数组槽范围 0~m

		核心算法
			1. 尽可能减少冲突次数
			2. 解决冲突是的办法。
				2.1 链表法（chaining)
				2.2 开放寻执法(open addressing)

			链表法性能
				给定可存放n个元素，m个槽位的散列表T，定义装在因子（load factor) a = n/m

				定理11.1	在简单均匀散列的假设下，一次不成功查找的平均时间为 H(1+a)
				定理11.2	在简单均匀散列的假设下，一次成功的查找的平均时间为 H(1+a)
		
		11.2-1题解：？？
		11.2-2题解：？？
		11.2-3题解：？？
		11.2-4题解：？？
		11.2-5题解：？？
		11.2-6题解：？？

	11.2 散列函数
		1. 除法散列
		2. 乘法散列
		3. 全域散列

		除法散列
			1. 函数：h(k) = k mod m
			2. m不可以是2的幂
			3. k全部为2的幂时，m=Power(2,p) - 1 是个糟糕的选择。
			4. 不太接近2的整数幂的质数是个较好的选择。

		乘法散列
			1. 函数：h(k) = [m(kA mod1)]   (kA mod1)是取kA的小数部分。A为不是整数的常数，
			2. 优点为对m的选择不是特别关键，一般选择它为2的某个幂。
			3. k全部为2的幂时，m=Power(2,p) - 1 是个糟糕的选择。
				w位整数 = r1 Power（2,w) + r0  (r1为高位，r0为低位)
			4. A的最佳值约等于黄金分割值 (0.618033...)

		--------------------------------------------------------------------------------------------
		全域散列法（universal hashing)  （超难）
			定义：
				设H是一组有限散列函数集合，它将给定的关键字全域UU映射到{0,1,2,3,...,m−1}
				这样的一个函数称为全域的，如果对于每一对不同的关键字k,l∈Uk,l∈U,
					满足h(k)=h(l)的散列函数
					h∈Hh∈H的个数至多是|H|/m|H|/m,
					也就是说，从H中选取一个散列函数hh,在k≠l的情况下，
					h(k)=h(l)的概率不大于1/m。
					这也正好是从集合0,1,2,3，...,m−1中独立的随机选取h(k)和h(l)发生冲突的概率。

			1. 针对特定散列函数都可能出现检索时间变成 H(n)的最坏结果。
			   有效对应方法就是随机地选择散列函数，使之独立于存储的关键字。
			
			2. 有效散列函数
			--------------------------------------------------------------------------------------------
			那要怎么设计一个全域散列函数类呢？
				0. 需要数论知识。（见31章）
				1. 首先选取一个足够大的素数p ,使得每一个可能的关键字落到0到p−1的范围内。
				2. ...... 看不懂

			--------------------------------------------------------------------------------------------
			全域哈希能解决普通哈希的什么问题？
				普通哈希的缺点就出来了：
					对任意的hash函数h,总存在一组keys使得,
						对某个槽i总可以找到一组键值，让他们都映射到同一个槽里面，这样效率就跟离链表差不多了。
				解决方法： 加入随机性

			公开课：https://open.163.com/newview/movie/free?pid=M6UTT5U0I&mid=M6V2TGI3A

			

Pg163～Pg173　(2021-0402)
第12章   二叉搜索树

Pg174～Pg192　(2021-0403)
第13章   红黑树

	参考笔记： https://javaman.now.sh/note/why-java-use-redblack-tree-in-hashmap/
		讲述内容，Java版本中进化不只是为了提升一点点性能，主要还是安全。

	红黑树
		属于高度为h的二叉搜索树
		平衡搜索数的一种
		时间复杂度为 O(lg(n))

	特性
		1. 确保没有一条路径比其他路径长2被，因此是近似平衡的。
		2. 每个节点非红即黑。
		3. 跟节点是黑色的。
		4. 每个叶节点（NIL）是黑色的。
		5. 每个节点到后代节点的简单路径上，均包含相同数目的黑色节点。

Pg193～Pg203　(2021-0403)

Pg541～
第31章   数论算法
	
	参考笔记：https://mengzelev.github.io/2019/04/06/clrs-31Number-Theoretic-Algorithms/

	高效计算 Power(a,b) mod n 的结果，是运行高效素数检测和现代密码学内容的核心部分。

		31.7  RSA公钥加密系统
		31.8  随机性素数测试方法，用来高效查找大素数。（RAS算法必需）
		31.9  小整数因子分解启发式算法。

	Pg541～Pg546
	31.1 基础数论概念
		

		1. 整除性与约数（1和因子）
			
			约数：24的约数为 1，2，3，4，6，8，12，24
				平凡约数：1
				非平凡约数: 2，3，4，6，8，12，24

			整除： d|a 读作d整除a, a是d的倍数。
					任何整数均可整除0.

		2. 素数和合数
				素数：约数只有平凡约数1和自身的数。
				最大公约数：计做 gcd(a,b)；

		定理31.1: 除法定理
				对于任何一个整数a，和正整数n，存在唯一整数q和r，满足 0<=r<n,且 a=qn+r
				人话：对于a,n （16，3），存在唯一一个整数q和r，满足  0<=r<3，且 16=q*3 + r.  （q=5,r=1)
				人话：对于a,n （3，16），存在唯一一个整数q和r，满足  0<=r<16，且 3=q*16 + r.  （q=0,r=1)

		定理31.2: 最大公约数定理 
				如果任意整数a，b不都为0，则 gcd(a,b)是a与b的线性组合集 {ax + by : x,y 属于 Z}中的最小正元素；
				人话：对于a,b （15，30），最大公约数是15，是15和30的线性组合 15x + 30y（15,45,60,75....)中的最小正元素。

		定理31.3: 整除定理
				对于任意整数a,b,如果d|a 且 d|b, 则 d|gcd(a,b)
				人话：对于a,b （15，18），如果d(90)能整除15，18，则d也能整除 gcd(15,18)=3;

		定理31.4: 最大公约数乘法定理
				对于所有整数a,b以及非负整数n,有 gcd(an,bn) = n gcd(a,b)
				人话：对于a,b （6，4），n=2, 则gcd(6*2,4*2)= gcd(12,8) = 2 * gcd(4,6) = 4;
		
		定理31.5: 最大公约数整除定理
				对于所有正整数n,a,b, 如果 n|ab, 且gcd(a,n) = 1,则 n|b
				人话：对于2, 3，4, 如果 2|3*4 (2|12), 且gcd(3,2) = 1， 则2|4;

		定理31.6: 互质定理
				对于任意整数a,b,p, 如果 gcd(a,p) = 1,则 gcd(b,p) = 1, 成a,b为互质数。
				人话：对于3,5,7, 如果 gcd(3,7) = 1, 则gcd(5,7) = 1，3与5互质。

		定理31.7: 约数定理
				对于所有素数p和所有整数a,b, 如果 p|ab,则 p|a 或 p|b		
				人话：对于(3),3,5,, 如果 (3)|3*5, 则(3)|3 或者 (3)|5
				人话：对于(7),14,2,, 如果 (7)|14*2, 则(7)|14 或者 (7)|2
		
		定理31.8: 唯一因子分解定理
				合数a仅能以一种方式写成如下乘积形式： a= Power(p1, e1) * Power(p2, e2) * Power(p3, e3) ...
				其中 p1 < p2 < p3 < ... pr, e1,e2,e3...为正整数；

				例: 6000可以分解为 = Power(2, 4) * Power(3, 1) * Power(5, 3)

	Pg547～Pg550
	31.1 最大公约数
		
		斐波那契数
		欧几里德算法（求最大公约数）[EUCLID: ユークリッド]

		定理31.9: GCD递归定理（求最大公约数递归定理）
			gcd(a,b) = gcd(b, a mod b)
			---------------------------------------
			EUCLID(a,b) {
				if b==0
					return a;
				else
					return EUCLID(b, a mod b)
			}
			---------------------------------------
			EUCLID(20,21) = EUCLID(21，9) = EUCLID(9,3) = EUCLID(3,0) = 3;

		引理31.10:  超难
			如果 a>b>=1,并且 EUCLID(a,b)执行了k>=1次递归调用，则 a>=F(k+2), b>=F(k+1).
			解释：F(k)为斐波那契数列的第k项。

				斐波那契数列（Fibonacci sequence）[フィボナッチすう]：
					
					F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)
					0，1，1，2，3，5，8，13，21，34，55，89，144，233，377，610
		
		引理31.11:  超难
			(Lame定理): 对任意整数k>1,如果a>b>1,且b<F{k+1},则EUCLID(a,b)的递归调用次数少于k次	


		欧几里德算法的扩展 （非常重要）
			EXTENDED-EUCLID
			---------------------------------------
			EXTENDED-EUCLID(a,b) {
				if b==0
					return a;
				else(d',x',y') = EXTENDED-EUCLID(b,a mod b)
					(d,x,y) = (d',y',x'- Math.floor(a/b)×y')
					return (d,x,y)
			}
			---------------------------------------
	Pg550～Pg554
	31.3 模运算  //全部没看懂
		
		//没看懂
		有限群（S,⊕）是一个集合S和定义在S上的二进制运算 ⊕,该运算满足
			1. 封闭性: 如果a∈S, b∈S, 则有 a⊕b∈S
			2. 单位元: 存在一个元素 e∈S,成为群的单位元，满足对所有a∈S，e⊕a = a⊕e = a.
			3. 结合律: 对于所有a,b,c∈S，有 (a⊕b)⊕c = a⊕(b⊕c)
			4. 逆元  : 对每个a∈S，存在唯一的元素b∈S，成为a的逆元，满足 a⊕b = b⊕a = e.

		引理31.12:  //没看懂
			系统（Zn,⊕n）是一个有限交换群

			例： Z15 = {1，2，34，7，8，11，13，14}
			    [7]15 = 7, Z15中， 8・11 = 13(mod 15) (补充 8*11=88 88%15=13）
				该群单位元为1。

		引理31.13:  //没看懂
			系统（Zn,・n）是一个有限交换群

			下面两种表示等价
				ax≡b(mod n)) 
				[a]n ・n [x]n = [b]n
				7的逆元≡13(mod 15)   因为7・13= 91≡1(mod 15)，这样就有 4/7≡4・13 = 7（mod 15)

		引理31.14:  一个有限群的非空封闭子集是一个子群	//没看懂
			 如果（S,⊕n）是一个有限群, S'是S的任意一个非空子集，并满足对所有a,b∈S', 有a⊕b∈S',则（S',⊕n）为（S,⊕n）的子群。

			子群:  
				如果（S,⊕n）是一个群, S'⊆S,并且（S',⊕n）也是一个群，则（S',⊕n）称为（S,⊕n）的子群。

		引理31.15:  拉格朗日定理 //没看懂
			如果（S,⊕n）是一个有限群, （S',⊕n）为（S,⊕n）的子群，则|S'|是|S|的一个约数。
			（另一种表述，来自百度）设 H 是有限群 G 的子群，则 H 的阶整除 G 的阶。

		引理31.16:  //没看懂
			 如果S'是有限群S的真子群，则|S'| <=|S|/2

			 真子群：如果 S'≠S , 称子群S'为S的真子群。

		引理31.17:  //没看懂
			 对于有限群（S,⊕n）和任意a∈S，一个元素的阶等于他所生成的子群的规模。即ord(a)=|<a>|。

			 <a>代表由a生成的子群，a是<a>的生成元。
			 orad(a) ，在群S中a的阶，定义为满足 Power(a,(t))= e的最小正整数t。
			
		引理31.18:  //没看懂
			 序列a(1),a(2)...是周期序列，其周期为t=ord(a),即 a(i)=a(j)当且仅当 i≡j(mod t)。

		引理31.19:  //没看懂
			 如果（S,⊕n）是一个单位元e的有限群，则所有a∈S。

	Pg554～Pg556
	31.4 求解模线性方程

	Pg554～Pg556
	31.4 求解模线性方程

	Pg556～Pg558
	31.5 中国余数定理
	
	Pg558～Pg561
	31.6 元素的幂

	Pg562～Pg565
	31.7 RSA公钥加密系统

	Pg566～Pg571
	*31.8 素数的测试
	
	Pg572～Pg574
	*31.9 整数的因子分解

	Pg575～Pg576
	思考题

	Pg577
	本章注记


	书籍原文的网站参考
	///https://blog.csdn.net/z84616995z/article/details/21945197

	算法导论部分习题解答
		https://sites.google.com/site/algorithmssolution/home/c2/2-4